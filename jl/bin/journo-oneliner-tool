#!/usr/bin/env python
#
# (oneliners are short description for journos, mainly to be
# displayed after their name in lists)

# Rebuild journo oneliner column, by using the newspapers
# the journo has written for to generate a short description.
# eg ("The Times, BBC News")
#

import sys
import site
site.addsitedir("../pylib")
from JL import DB,ukmedia
from optparse import OptionParser
import logging
from pprint import pprint

def run_all():
    c = DB.conn().cursor()
    c.execute("SELECT id,ref,prettyname,oneliner FROM journo")
    for j in c:
        try:
            do_journo(j)
        except Exception as e:
            logging.error("ERROR doing '%s'" % (j['ref'],))

def run_single(ref):
    c = DB.conn().cursor()
    c.execute("SELECT id,ref,prettyname,oneliner FROM journo WHERE ref=%s", (ref,))
    j = c.fetchone()
    if j is None:
        logging.error("couldn't find %s"%(ref,))
        return
    do_journo(j)



def do_journo(j):
    desc = build_oneliner( j['id'] )
    if desc != j['oneliner']:
        c = DB.conn().cursor()
        c.execute("""UPDATE journo SET oneliner=%s WHERE id=%s""", (desc.encode('utf-8'), j['id']))
    logging.info( "%s: was '%s' now '%s'" % (j['ref'], j['oneliner'], desc))



def build_oneliner(journo_id):
    """ builds a short description for journo """

    desc = u''
    cursor = DB.conn().cursor()

    # any current employment?
    cursor.execute( """SELECT kind,employer FROM journo_employment WHERE current=true AND journo_id=%s ORDER BY year_from DESC""", (journo_id,) )
    rows = cursor.fetchall()

    if len(rows) > 0:
        employers = []
        for r in rows:
            if r['kind'] == 'f':
                employers.append( u'Freelance' )
            else:
                employers.append( r['employer'].decode('utf-8'))

        # clip to 3 employers max
        employers = employers[:3]
        if len(employers) > 0:
            desc = u', '.join( employers )
            return desc

    # no employment info - guess using papers they've written for
    # TODO: should give more weight to newer articles
    sql = """SELECT o.prettyname, count(o.prettyname)
        FROM (organisation o INNER JOIN article a ON o.id=a.srcorg)
            INNER JOIN journo_attr attr ON attr.article_id=a.id
        WHERE a.status='a' AND attr.journo_id=%s
        GROUP BY o.prettyname"""
    cursor.execute(sql,(journo_id,)) 
    candidates = [(row['prettyname'].decode('utf-8'),int(row['count'])) for row in cursor]
    total = float(sum([c[1] for c in candidates]))
#    if total < 3:
#        return desc
    candidates = [(c[0], float(c[1])/total) for c in candidates]
    candidates = [c for c in candidates if c[1]>0.33]
    candidates = sorted(candidates, key=lambda c: c[1], reverse=True)

    candidates = candidates[:2]
    desc = u', '.join([c[0] for c in candidates] )
    return desc


def main():
    parser = OptionParser()
    parser.add_option('-v', '--verbose', action='store_true')
    parser.add_option('-t', '--test', action='store_true', help="test only - don't commit to db")
    parser.add_option('-j', '--journo', help="just update oneliner for given journo ref (default is to do all who need em)")
    (options, args) = parser.parse_args()
    log_level = logging.ERROR
    if options.verbose:
        log_level = logging.INFO
    logging.basicConfig(level=log_level, format='%(message)s')
    if options.test:
        logging.warn("TEST RUN - DB won't be touched")

    if options.journo:
        run_single(options.journo)
    else:
        run_all()

    if options.test:
        logging.warn("rollback()")
        DB.conn().rollback()
    else:
        DB.conn().commit()


if __name__ == "__main__":
    main()


